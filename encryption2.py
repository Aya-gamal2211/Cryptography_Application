import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from secrets import token_bytes

key = token_bytes(16)
key_hashed =hashlib.sha256(key).digest()

def encrpt_msg(msg):
    # padding to make the length of the input data a multiple of the block size (16 bytes for AES).
    padded_msg = pad(msg.encode(), AES.block_size)
    cipher= AES.new(key_hashed,AES.MODE_EAX)
    # nonce is random bytes generated by each cipher to add more consistency during decryption
    nonce = cipher.nonce
    # This function is responsible for both encrypting the provided plaintext message and computing an authentication tag for the ciphertext.
    cipherText,tag = cipher.encrypt_and_digest(padded_msg)
    return nonce , cipherText ,tag

def decrypt_msg(nonce , cipherText ,tag):

    cipher= AES.new(key_hashed, AES.MODE_EAX, nonce=nonce)
    plainText = cipher.decrypt(cipherText)

    try:
        cipher.verify(tag)
        # Unpad the decrypted plaintext to remove any padding added during encryption
        unpadded_plainText = unpad(plainText, AES.block_size)
        return unpadded_plainText.decode('utf-8')
    
    except ValueError:
        return False
    
nonce , cipherText ,tag = encrpt_msg(input('Enter the msg you want to encrypt: '))
plainText = decrypt_msg(nonce,cipherText ,tag)
print(f'The cipher text is : {cipherText}')
if not plainText:
    print('Message is corrupted')
else :
    print(f'PlainText is {plainText}')


